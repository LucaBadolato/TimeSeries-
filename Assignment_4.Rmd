---
title: "20236 Time Series Analysis - Assignment 4"
author:
- Simone Arrigoni (1794692)
- Luca Badolato (3086040)
- Simone Valle (3088281)
subtitle: "Bocconi University"
date: April 4, 2020
output: 
  pdf_document
header-includes:
  \usepackage[utf8]{inputenc}
  \usepackage{setspace}
  \usepackage{algpseudocode}
  \usepackage{algorithm}
  \usepackage{bm}
  \usepackage{amsmath}
  \usepackage{amssymb}
  \usepackage{graphicx}
  \usepackage{subfig}
  \usepackage{booktabs, caption}
  \usepackage{array}
  \usepackage{threeparttable}
  \usepackage{listings}
  \usepackage{physics}
  \usepackage{float}
  \floatplacement{figure}{H}
  \usepackage{color} %red, green, blue, yellow, cyan, magenta, black, white
  \definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
  \definecolor{mylilas}{RGB}{170,55,241}
  \DeclareMathOperator*{\E}{\mathbb{E}}
  \DeclareMathOperator*{\Ec}{\mathbb{E}_t}
---

```{r, include=FALSE}

# Load useful packages
library(utf8)
library(labeling)
library(rmarkdown)
library(httr)
library(knitr)
library(tseries)
library(scales)
library(dlm)
library(depmixS4)
library(tidyr)
library(tidyverse)
library(ggthemes)
library(magrittr)
library(latex2exp)
library(kableExtra)
library(ggpubr)

# Settings
knitr::opts_chunk$set(message = FALSE, 
                      warning = FALSE,
                      echo    = FALSE,
                      include = TRUE,
                      fig.pos = "H",
                      fig.align = "center")
```

\section{Exercise}

In this exercise we use the dataset \texttt{data\_a4.csv}, which contains monthly data for the period January 1997 to July 2019 including 10 years Italian government bond's interest rate, inflation represented by the Harmonised Index of Consumer Prices (HICP) and default ratings assigned by Moody's and Fitch in the investment grade range.
The structure of the dataset can be seen in Table \ref{tab:data}, where the first observations are listed.

```{r echo=FALSE}
# Import the dataset
data_a4 <- read.csv(url("https://raw.githubusercontent.com/LucaBadolato/TimeSeries-/master/data_a4.csv"), sep = ",", header=T)
data_a4$Time <- as.Date(data_a4$Time, tryFormats = c("%Y_%m_%d"), optional = FALSE)
```
```{r}
# How the dataset looks like
knitr::kable(data_a4[1:5,], "latex", booktabs=T,
             caption="Dataset structure\\label{tab:data}") %>%
  kable_styling(latex_options="hold_position")
```

\begin{enumerate}

\item %1
Let's consider the \textit{real} interest rate for the 10 years Italian government bond, i.e. the ratio between the \textit{nominal} interest rate and the Harmonised Index of Consumer Prices (HICP).
Figure \ref{fig:ITAbond_real} plots the time series for the \textit{real} interest rate.

```{r, fig.width=6, fig.height=2.5, fig.cap="\\label{fig:ITAbond_real}Real interest rate for the 10 years Italian government bond"}

# Time series plot
ggplot(data_a4, aes(x=Time, y=ITAbond_real)) +
  geom_line(color="steelblue") +
  theme_classic(base_size=9) +
  labs(y="Real interest rate", x="Date") +
  scale_x_date(date_breaks="2 years", date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'), tryFormats=c("%Y_%m_%d"),
                              optional=FALSE), labels=date_format("%m/%Y")) +
  scale_y_continuous(breaks = seq(0,6,0.5)) +
  theme(axis.text.x=element_text(angle=45, hjust=1),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5)))
```

The time series is clearly non-stationary and there seems to be several change points, the most clear of which being at the end of 2008, in correspondence to the beginning of the Great recession. In light of the presence of these structural breaks, a transformation of the series into a stationary one is also unlikely to be carried out. For these reasons, a Hidden Markov Model (HMM) could be a reasonable choice for modelling this time series.

Let's indeed model the series using a HMM. In particular, let's assume:
\begin{itemize}
\item three states, representing respectively boom (low interest rates), recession (high interest rates) and a stable path;
\item Gaussian emission distributions, with state-dependent mean $\mu_i$ and variance $\sigma_i$ with $i=1,2,3$;
\item No trend clearly shows up from the time series plot suggesting that the data oscillates around a reference value.
\end{itemize}

Then, we may specify a Gaussian HMM for the interest rate series in its simplest form, i.e. as long-term mean plus noise
\begin{align*}
\begin{cases}
Y_{t}=\mu_{1}+\varepsilon_{t}, \quad \varepsilon_{t}\overset{i.i.d.}{\sim}N(0,\sigma_{1}^2) \qquad \text{if} \; S_{t}=1 \\
Y_{t}=\mu_{2}+\varepsilon_{t}, \quad \varepsilon_{t}\overset{i.i.d.}{\sim}N(0,\sigma_{2}^2) \qquad \text{if} \; S_{t}=2 \\
Y_{t}=\mu_{3}+\varepsilon_{t}, \quad \varepsilon_{t}\overset{i.i.d.}{\sim}N(0,\sigma_{3}^2) \qquad \text{if} \; S_{t}=3
\end{cases}
\end{align*}

```{r}
# 1) Model specification
y <- as.numeric(data_a4$ITAbond_real)
model <- depmixS4::depmix(y ~ 1, data=data.frame(y), nstates=3)
```

We can now estimate the MLE of the unknown parameters of the model.
Table \ref{tab:HMM_MLE} presents the estimates the mean and standard deviation in the three states as well as their standard errors.
\medskip

\textcolor{red}{Quelli riportati nella tabella seguente (ottenuta su LaTeX inserendo manualmente i valori) sono i valori corretti. È possibile che nella tabella ancora seguente (ottenuta su R con "kable" salvando i valori nell'environment) le righe siano invertite. Non c'è problema, finché non assegniamo a ciascuno stato uno specifico market regime (e.g., S=1 è recessione), cosa che non abbiamo fatto.}
\begin{table}[H]
\centering
{\color{red}\begin{tabular}{ccc}
\toprule
State & $\hat{\mu}_{MLE}$ & $\hat{\sigma}_{MLE}$ \\
\midrule
S=1   & 1.29               & 0.351                 \\
      & (0.067)            & (0.033)               \\
S=2   & 3.169              & 0.737                 \\
      & (0.071)            & (0.049)               \\
S=3   & 2.019              & 0.207                 \\
      & (0.055)            & (0.033) \\ \bottomrule
\end{tabular}}
\end{table}

```{r include=FALSE}
# 2) Model estimation
fmodel <- depmixS4::fit(model)
depmixS4::summary(fmodel)
```
```{r}
#MLE
mu1hat <- paste0(round(fmodel@response[[1]][[1]]@parameters$coefficients,3))
mu2hat <- paste0(round(fmodel@response[[2]][[1]]@parameters$coefficients,3))
mu3hat <- paste0(round(fmodel@response[[3]][[1]]@parameters$coefficients,3))
sd1hat <- paste0(round(fmodel@response[[1]][[1]]@parameters$sd,3))
sd2hat <- paste0(round(fmodel@response[[2]][[1]]@parameters$sd,3))
sd3hat <- paste0(round(fmodel@response[[3]][[1]]@parameters$sd,3))
# se(MLE)
MLEse=depmixS4::standardError(fmodel)
se_mu1hat <- paste0('(', round(MLEse$se[13],3), ')')
se_mu2hat <- paste0('(', round(MLEse$se[15],3), ')')
se_mu3hat <- paste0('(', round(MLEse$se[17],3), ')')
se_sd1hat <- paste0('(', round(MLEse$se[14],3), ')')
se_sd2hat <- paste0('(', round(MLEse$se[16],3), ')')
se_sd3hat <- paste0('(', round(MLEse$se[18],3), ')')
```
```{r}
# Summary table creation
MLEsum <- data.frame(state=c(rep("S=1",2), rep("S=2",2), rep("S=3",2)),
                     mu=c(mu1hat, se_mu1hat, mu2hat, se_mu2hat, mu3hat, se_mu3hat),
                     sd=c(sd1hat, se_sd1hat, sd2hat, se_sd2hat, sd3hat, se_sd3hat))
knitr::kable(MLEsum, "latex", booktabs=T, align="c",
             col.names = c("State", "$\\hat{\\mu}_{MLE}$", "$\\hat{\\sigma}_{MLE}$"),
             escape=F, caption="Maximum Likelihood estimates of the state-dependent
             mean and standard deviation\\label{tab:HMM_MLE}") %>%
  column_spec(1:3, width="5em") %>%
  collapse_rows(columns=1, latex_hline="none") %>%
  footnote(general="Standard errors in parentheses",
           general_title="Note:",
           footnote_as_chunk=T, escape=F) %>%
  kable_styling(latex_options="hold_position")
```

Finally, we find the optimal state variable path given the observed real interest rates, that is, we proceed with a global decoding procedure based on the \textit{Viterbi algorithm}. Viterbi states and state-dependent means are plotted respectively in Figure \ref{fig:model_fit_ost} and Figure \ref{fig:model_fit_rsm}.

```{r}
# Get the estimated state for each timestep 
estStates <- posterior(fmodel)
```

```{r, fig.width=6.5, fig.height=3, fig.cap="\\label{fig:model_fit_ost}Optimal state trajectory"}

# Plot the optimal path, that is stored in the first column of estStates
F1 <- ggplot(data.frame(data_a4[1],data_a4[6], estStates[1])) +
  geom_line(aes(x=Time,y=ITAbond_real)) +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="Real interest rate", x="Date") +
  scale_x_date(date_breaks="3 years", 
               date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'),
                              tryFormats=c("%Y_%m_%d"),
                              optional=FALSE),
               labels=date_format("%Y-%m")) +
  scale_y_continuous(breaks=seq(0,6,1)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("Real interest rate")

S1 <- ggplot(data.frame(data_a4[1],data_a4[6], estStates[1])) +
  geom_line(aes(x=Time, y=state), 
            linetype="solid", 
            color="red") +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="State", x="Date") +
  scale_x_date(date_breaks="3 years", 
               date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'),
                              tryFormats=c("%Y_%m_%d"),
                              optional=FALSE),
               labels=date_format("%Y-%m")) +
  scale_y_continuous(breaks=seq(0,3,1)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("Viterbi states")

# Merge graphs in one plot
ggarrange(F1, S1,
          ncol=1, nrow=2)
```

```{r, fig.width=6, fig.height=2.5, fig.cap="\\label{fig:model_fit_rsm}Regime switching mean"}

# Chart with state-dependent mean
estMeans=matrix(0, length(data_a4[,1]),3)

for (i in 1:3) {
  for (j in 1:length(data_a4[,1])) {
    if (estStates[j,1]==i){
      estMeans[j,i]<-fmodel@response[[i]][[1]]@parameters$coefficients
   }else{
      estMeans[j,i]<-0
   }
  }
}

switching_mean <- estMeans[,1]+estMeans[,2]+estMeans[,3]

ggplot(data.frame(switching_mean, data_a4[1],data_a4[6])) +
  geom_line(aes(x=Time, y=ITAbond_real)) +
  geom_point(aes(x=Time, y=switching_mean), col="blue", size=.05) +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="Real interest rate", x="Date") +
  scale_x_date(date_breaks="2 years",
               date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'),
                              tryFormats=c("%Y_%m_%d"),
                              optional=FALSE),
               labels=date_format("%Y-%m")) +
  scale_y_continuous(breaks = seq(0,6,0.5)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("State dependent mean")
```

\item %2
We now use a non-homogeneous HMM, namely we allow the transition matrix to depend on covariates, in order to \textit{predict} possible change points in our time series.

```{r}
# 1) Model specification for non-homogeneous HMM
y_nh <- as.numeric(data_a4$ITAbond_real)
model_nh <- depmixS4::depmix(y_nh ~ 1, data=data.frame(y_nh), nstates=3, transition=~ y_nh)
```

We proceed exactly as above and first estimate the MLE of the unknown parameters of the model.
Table \ref{tab:HMM_MLE_nh} presents the estimates the mean and standard deviation in the three states as well as their standard errors.

```{r include=FALSE}
# 2) Model estimation for non-homogeneous HMM
fmodel_nh <- depmixS4::fit(model_nh)
depmixS4::summary(fmodel_nh)
```
```{r}
# MLE
mu1hat_nh <- paste0(round(fmodel_nh@response[[1]][[1]]@parameters$coefficients,3))
mu2hat_nh <- paste0(round(fmodel_nh@response[[2]][[1]]@parameters$coefficients,3))
mu3hat_nh <- paste0(round(fmodel_nh@response[[3]][[1]]@parameters$coefficients,3))
sd1hat_nh <- paste0(round(fmodel_nh@response[[1]][[1]]@parameters$sd,3))
sd2hat_nh <- paste0(round(fmodel_nh@response[[2]][[1]]@parameters$sd,3))
sd3hat_nh <- paste0(round(fmodel_nh@response[[3]][[1]]@parameters$sd,3))
# se(MLE)
MLEse_nh=depmixS4::standardError(fmodel_nh)
se_mu1hat_nh <- paste0('(', round(MLEse_nh$se[22],3), ')')
se_mu2hat_nh <- paste0('(', round(MLEse_nh$se[24],3), ')')
se_mu3hat_nh <- paste0('(', round(MLEse_nh$se[26],3), ')')
se_sd1hat_nh <- paste0('(', round(MLEse_nh$se[23],3), ')')
se_sd2hat_nh <- paste0('(', round(MLEse_nh$se[25],3), ')')
se_sd3hat_nh <- paste0('(', round(MLEse_nh$se[27],3), ')')
```
```{r}
# Summary table creation
MLEsum <- data.frame(state=c(rep("S=1",2), rep("S=2",2), rep("S=3",2)),
                     mu=c(mu1hat_nh, se_mu1hat_nh, mu2hat_nh, se_mu2hat_nh,
                          mu3hat_nh, se_mu3hat_nh),
                     sd=c(sd1hat_nh, se_sd1hat_nh, sd2hat_nh, se_sd2hat_nh,
                          sd3hat_nh, se_sd3hat_nh))
knitr::kable(MLEsum, "latex", booktabs=T, align="c",
             col.names = c("State", "$\\hat{\\mu}_{MLE}$", "$\\hat{\\sigma}_{MLE}$"),
             escape=F, caption="Maximum Likelihood estimates of the state-dependent
             mean and standard deviation\\label{tab:HMM_MLE_nh}") %>%
  column_spec(1:3, width="5em") %>%
  collapse_rows(columns=1, latex_hline="none") %>%
  footnote(general="Standard errors in parentheses",
           general_title="Note:",
           footnote_as_chunk=T, escape=F) %>%
  kable_styling(latex_options="hold_position")
```

Then, in order to find the optimal state variable path, we perform the global decoding procedure based on the \textit{Viterbi algorithm}.
Viterbi states and state-dependent means in the non-homogeneous HMM case are plotted respectively in Figure \ref{fig:model_fit_ost_nh} and Figure \ref{fig:model_fit_rsm_nh}.

```{r}
# Get the estimated state for each timestep 
estStates_nh <- posterior(fmodel_nh)
```

```{r, fig.width=6.5, fig.height=3, fig.cap="\\label{fig:model_fit_ost_nh}Optimal state trajectory (non-homogeneous HMM)"}

# Plot the optimal path, that is stored in the first column of estStates
F1_nh <- ggplot(data.frame(data_a4[1],data_a4[6], estStates_nh[1]))+
  geom_line(aes(x=Time,y=ITAbond_real)) +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="Real interest rate", x="Date") +
  scale_x_date(date_breaks="3 years", 
               date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'),
                              tryFormats=c("%Y_%m_%d"),
                              optional=FALSE),
               labels=date_format("%Y-%m")) +
  scale_y_continuous(breaks=seq(0,6,1)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("Real interest rate")

S1_nh <- ggplot(data.frame(data_a4[1],data_a4[6], estStates_nh[1])) +
  geom_line(aes(x=Time, y=state), 
            linetype="solid", 
            color="red") +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="State", x="Date") +
  scale_x_date(date_breaks="3 years", 
               date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'),
                              tryFormats=c("%Y_%m_%d"),
                              optional=FALSE),
               labels=date_format("%Y-%m")) +
  scale_y_continuous(breaks=seq(0,3,1)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("Viterbi states")

# Merge graphs in one plot
ggarrange(F1_nh, S1_nh,
          ncol=1, nrow=2)
```

```{r, fig.width=6, fig.height=2.5, fig.cap="\\label{fig:model_fit_rsm_nh}Regime switching mean (non-homogeneous HMM)"}

# Chart with state-dependent mean
estMeans_nh=matrix(0, length(data_a4[,1]),3)

for (i in 1:3) {
  for (j in 1:length(data_a4[,1])) {
    if (estStates_nh[j,1]==i){
      estMeans_nh[j,i]<-fmodel_nh@response[[i]][[1]]@parameters$coefficients
   }else{
      estMeans_nh[j,i]<-0
   }
  }
}

switching_mean_nh <- estMeans_nh[,1]+estMeans_nh[,2]+estMeans_nh[,3]

ggplot(data.frame(switching_mean_nh, data_a4[1],data_a4[6])) +
  geom_line(aes(x=Time, y=ITAbond_real)) +
  geom_point(aes(x=Time, y=switching_mean_nh), col="blue", size=.05) +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="Real interest rate", x="Date") +
  scale_x_date(date_breaks="2 years",
               date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'),
                              tryFormats=c("%Y_%m_%d"),
                              optional=FALSE),
               labels=date_format("%Y-%m")) +
  scale_y_continuous(breaks = seq(0,6,0.5)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("State dependent mean")
```

\end{enumerate}

\section{Final project: First part}

Our idea:
