---
title: "20236 Time Series Analysis - Assignment 4"
author:
- Simone Arrigoni (1794692)
- Luca Badolato (3086040)
- Simone Valle (3088281)
subtitle: "Bocconi University"
date: April 4, 2020
output: 
  pdf_document
header-includes:
  \usepackage[utf8]{inputenc}
  \usepackage{setspace}
  \usepackage{algpseudocode}
  \usepackage{algorithm}
  \usepackage{bm}
  \usepackage{amsmath}
  \usepackage{amssymb}
  \usepackage{graphicx}
  \usepackage{subfig}
  \usepackage{booktabs, caption}
  \usepackage{array}
  \usepackage{threeparttable}
  \usepackage{listings}
  \usepackage{physics}
  \usepackage{float}
  \floatplacement{figure}{H}
  \usepackage{color} %red, green, blue, yellow, cyan, magenta, black, white
  \definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
  \definecolor{mylilas}{RGB}{170,55,241}
  \DeclareMathOperator*{\E}{\mathbb{E}}
  \DeclareMathOperator*{\Ec}{\mathbb{E}_t}
---

```{r, include=FALSE}

# Load useful packages
library(utf8)
library(labeling)
library(rmarkdown)
library(httr)
library(knitr)
library(tseries)
library(scales)
library(dlm)
library(depmixS4)
library(tidyr)
library(tidyverse)
library(ggthemes)
library(magrittr)
library(latex2exp)
library(kableExtra)
library(ggpubr)

# Settings
knitr::opts_chunk$set(message = FALSE, 
                      warning = FALSE,
                      echo    = FALSE,
                      include = TRUE,
                      fig.pos = "H",
                      fig.align = "center")
```

\section{Exercise}

In this exercise we use the dataset \texttt{data\_a4.csv}, which contains monthly data for the period January 1997 to July 2019 including 10 years Italian government bond's interest rate, inflation represented by the Harmonised Index of Consumer Prices (HICP) and default ratings assigned by Moody's and Fitch in the investment grade range.
The structure of the dataset can be seen in Table \ref{tab:data}, where the first observations are listed.

```{r echo=FALSE}
# Import the dataset
data_a4 <- read.csv(url("https://raw.githubusercontent.com/LucaBadolato/TimeSeries-/master/data_a4.csv"), sep = ",", header=T)
data_a4$Time <- as.Date(data_a4$Time, tryFormats = c("%Y_%m_%d"), optional = FALSE)
```
```{r}
# How the dataset looks like
knitr::kable(data_a4[1:5,], "latex", booktabs=T,
             caption="Dataset structure\\label{tab:data}") %>%
  kable_styling(latex_options="hold_position")
```

\begin{enumerate}

\item %1
Let's consider the \textit{real} interest rate for the 10 years Italian government bond, i.e. the ratio between the \textit{nominal} interest rate and the Harmonised Index of Consumer Prices (HICP).
Figure \ref{fig:ITAbond_real} plots the time series for the \textit{real} interest rate.

```{r, fig.width=6, fig.height=2.5, fig.cap="\\label{fig:ITAbond_real}Real interest rate for the 10 years Italian government bond"}

# Time series plot
ggplot(data_a4, aes(x=Time, y=ITAbond_real)) +
  geom_line(color="steelblue") +
  theme_classic(base_size=9) +
  labs(y="Real interest rate", x="Date") +
  scale_x_date(date_breaks="2 years", date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'), tryFormats=c("%Y_%m_%d"),
                              optional=FALSE), labels=date_format("%m/%Y")) +
  scale_y_continuous(breaks = seq(0,6,0.5)) +
  theme(axis.text.x=element_text(angle=45, hjust=1),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5)))
```

The time series is clearly non-stationary and there seems to be several change points, the most clear of which being at the end of 2008, in correspondence to the beginning of the Great recession. In light of the presence of these structural breaks, a transformation of the series into a stationary one is also unlikely to be carried out. For these reasons, a Hidden Markov Model (HMM) could be a reasonable choice for modelling this time series.

Let's indeed model the series using a HMM. Specifically, in this exercise we use a homogeneous HMM, namely we assume that the hidden process $(S_{t})_{t\geq0}$ is a homogeneous Markov chain.

\textbf{Step 1: Model specification}

Let's assume:
\begin{itemize}
\item three states, representing respectively boom (low interest rates), recession (high interest rates) and a stable path;
\item Gaussian emission distributions, with state-dependent mean $\mu_i$ and variance $\sigma_i$ with $i=1,2,3$.
\item \textcolor{red}{No trend clearly shows up from the time series plot suggesting that the data oscillates around a reference value. --> Da riposizionare: qui stiamo facendo assumptions}
\end{itemize}

The model we want to specify for the interest rate time series is thus a Gaussian HMM in its simplest form, i.e. a long-term mean plus noise.
\begin{align*}
\begin{cases}
Y_{t}=\mu_{1}+\varepsilon_{t}, \quad \varepsilon_{t}\overset{i.i.d.}{\sim}N(0,\sigma_{1}^2) \qquad \text{if} \; S_{t}=1 \\
Y_{t}=\mu_{2}+\varepsilon_{t}, \quad \varepsilon_{t}\overset{i.i.d.}{\sim}N(0,\sigma_{2}^2) \qquad \text{if} \; S_{t}=2 \\
Y_{t}=\mu_{3}+\varepsilon_{t}, \quad \varepsilon_{t}\overset{i.i.d.}{\sim}N(0,\sigma_{3}^2) \qquad \text{if} \; S_{t}=3
\end{cases}
\end{align*}

```{r}
# 1) Model specification
y <- as.numeric(data_a4$ITAbond_real)
model <- depmixS4::depmix(y ~ 1, data=data.frame(y), nstates=3)
```

\textbf{Step 2: Estimation of the unknown parameters}

We can now estimate the MLE of the unknown parameters of the model.
Table \ref{tab:HMM_MLE} presents the estimates the mean and standard deviation in the three states as well as their standard errors.
\medskip

\textcolor{red}{Quelli riportati nella tabella seguente (ottenuta su LaTeX inserendo manualmente i valori) sono i valori corretti. È possibile che nella tabella ancora seguente (ottenuta su R con "kable" salvando i valori nell'environment) le righe siano invertite. Non c'è problema, finché non assegniamo a ciascuno stato uno specifico market regime (e.g., S=1 è recessione), cosa che non abbiamo fatto.}
\begin{table}[H]
\centering
{\color{red}\begin{tabular}{ccc}
\toprule
State & $\hat{\mu}_{MLE}$ & $\hat{\sigma}_{MLE}$ \\
\midrule
S=1   & 1.29               & 0.351                 \\
      & (0.067)            & (0.033)               \\
S=2   & 3.169              & 0.737                 \\
      & (0.071)            & (0.049)               \\
S=3   & 2.019              & 0.207                 \\
      & (0.055)            & (0.033) \\ \bottomrule
\end{tabular}}
\end{table}

```{r include=FALSE}
# 2) Estimation of the unknown parameters
fmodel <- depmixS4::fit(model)
depmixS4::summary(fmodel)
```
```{r}
# MLE
mu1hat <- paste0(round(fmodel@response[[1]][[1]]@parameters$coefficients,3))
mu2hat <- paste0(round(fmodel@response[[2]][[1]]@parameters$coefficients,3))
mu3hat <- paste0(round(fmodel@response[[3]][[1]]@parameters$coefficients,3))
sd1hat <- paste0(round(fmodel@response[[1]][[1]]@parameters$sd,3))
sd2hat <- paste0(round(fmodel@response[[2]][[1]]@parameters$sd,3))
sd3hat <- paste0(round(fmodel@response[[3]][[1]]@parameters$sd,3))
# se(MLE)
MLEse=depmixS4::standardError(fmodel)
se_mu1hat <- paste0('(', round(MLEse$se[13],3), ')')
se_mu2hat <- paste0('(', round(MLEse$se[15],3), ')')
se_mu3hat <- paste0('(', round(MLEse$se[17],3), ')')
se_sd1hat <- paste0('(', round(MLEse$se[14],3), ')')
se_sd2hat <- paste0('(', round(MLEse$se[16],3), ')')
se_sd3hat <- paste0('(', round(MLEse$se[18],3), ')')
```
```{r}
# Build a summary table
MLEsum <- data.frame(state=c(rep("S=1",2), rep("S=2",2), rep("S=3",2)),
                     mu=c(mu1hat, se_mu1hat, mu2hat, se_mu2hat, mu3hat, se_mu3hat),
                     sd=c(sd1hat, se_sd1hat, sd2hat, se_sd2hat, sd3hat, se_sd3hat))
knitr::kable(MLEsum, "latex", booktabs=T, align="c",
             col.names = c("State", "$\\hat{\\mu}_{MLE}$", "$\\hat{\\sigma}_{MLE}$"),
             escape=F, caption="Maximum Likelihood estimates of the state-dependent
             mean and standard deviation\\label{tab:HMM_MLE}") %>%
  column_spec(1:3, width="5em") %>%
  collapse_rows(columns=1, latex_hline="none") %>%
  footnote(general="Standard errors in parentheses",
           general_title="Note:",
           footnote_as_chunk=T, escape=F) %>%
  kable_styling(latex_options="hold_position")
```

\textbf{Step 3: Decoding}

Finally, we find the optimal state variable path given the observed real interest rates, that is, we proceed with a global decoding procedure based on the \textit{Viterbi algorithm}.
Viterbi states are plotted in Figure \ref{fig:model_fit_ost}.

```{r}
# Get the estimated state for each timestep 
estStates <- posterior(fmodel)
```

```{r, fig.width=6, fig.height=3, fig.cap="\\label{fig:model_fit_ost}Optimal state trajectory"}

# Plot the optimal path, that is stored in the first column of estStates
F1 <- ggplot(data.frame(data_a4[1],data_a4[6], estStates[1])) +
  geom_line(aes(x=Time,y=ITAbond_real)) +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="Real interest rate", x="Date") +
  scale_x_date(date_breaks="3 years", 
               date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'),
                              tryFormats=c("%Y_%m_%d"),
                              optional=FALSE),
               labels=date_format("%Y-%m")) +
  scale_y_continuous(breaks=seq(0,6,1)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("Real interest rate")

S1 <- ggplot(data.frame(data_a4[1],data_a4[6], estStates[1])) +
  geom_line(aes(x=Time, y=state), 
            linetype="solid", 
            color="black") +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="State", x="Date") +
  scale_x_date(date_breaks="3 years", 
               date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'),
                              tryFormats=c("%Y_%m_%d"),
                              optional=FALSE),
               labels=date_format("%Y-%m")) +
  scale_y_continuous(breaks=seq(0,3,1)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("Viterbi states")

# Merge graphs in one plot
ggarrange(F1, S1,
          ncol=1, nrow=2)
```

\textcolor{red}{Another way to combine the two plots is shown in Figure \ref{fig:model_fit_ost2}.}

```{r, fig.width=6, fig.height=3, fig.cap="\\label{fig:model_fit_ost2}Optimal state trajectory"}

# Plot the optimal path, that is stored in the first column of estStates
results_df <- data.frame(time_index=data_a4$Time,
                         interest_rate=data_a4$ITAbond_real,
                         state=estStates[1]) %>% 
  gather("variable", "value", -time_index)

my_breaks <- function(x) { if (max(x)<4) seq(0,3,1) else seq(0,6,1) }
lab_names <- c(
  'interest_rate'="Real interest rate", 
  'state'="Viterbi state")

plotobj <- ggplot(results_df, aes(time_index, value)) +
  geom_line(color="red") +
  facet_wrap(variable~., scales="free", ncol=1,
             strip.position="left",
             labeller = as_labeller(lab_names)) +
  labs(x="Date") +
  scale_y_continuous(breaks=my_breaks) +
  scale_x_date(date_breaks="3 years",
               date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'),
                              tryFormats=c("%Y_%m_%d"),
                              optional=FALSE),
               labels=date_format("%Y-%m")) +
  theme_classic(base_size=9) +
  theme(axis.title.x=element_text(family="Times", margin=margin(5,0,0,0)),
        axis.title.y=element_blank(),
        strip.text.x=element_text(family="Times", face="bold",
                                  margin=margin(10,0,0,0)),
        strip.background=element_rect(colour="black", fill=NA),
        strip.placement="outside")

plot(plotobj)
```

The interest rates series with HMM estimated state-dependent means are shown in Figure \ref{fig:model_fit_rsm}.

```{r, fig.width=6, fig.height=2.5, fig.cap="\\label{fig:model_fit_rsm}Regime switching mean"}

# Chart with state-dependent mean
estMeans=matrix(0, length(data_a4[,1]),3)

for (i in 1:3) {
  for (j in 1:length(data_a4[,1])) {
    if (estStates[j,1]==i){
      estMeans[j,i]<-fmodel@response[[i]][[1]]@parameters$coefficients
   }else{
      estMeans[j,i]<-0
   }
  }
}

switching_mean <- estMeans[,1]+estMeans[,2]+estMeans[,3]

ggplot(data.frame(switching_mean, data_a4[1],data_a4[6])) +
  geom_line(aes(x=Time, y=ITAbond_real)) +
  geom_point(aes(x=Time, y=switching_mean), col="blue", size=.05) +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="Real interest rate", x="Date") +
  scale_x_date(date_breaks="2 years",
               date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'),
                              tryFormats=c("%Y_%m_%d"),
                              optional=FALSE),
               labels=date_format("%Y-%m")) +
  scale_y_continuous(breaks = seq(0,6,0.5)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("State dependent mean")
```

\item %2
We now use a non-homogeneous HMM, namely we allow the transition matrix to depend on covariates, in order to \textit{predict} possible change points in our time series.

```{r}
# 1) Model specification for non-homogeneous HMM
y_nh <- as.numeric(data_a4$ITAbond_real)
model_nh <- depmixS4::depmix(y_nh ~ 1, data=data.frame(y_nh), nstates=3, transition=~ y_nh)
```

We proceed exactly as above and first estimate the MLE of the unknown parameters of the model.
Table \ref{tab:HMM_MLE_nh} presents the estimates the mean and standard deviation in the three states as well as their standard errors.

```{r include=FALSE}
# 2) Model estimation for non-homogeneous HMM
fmodel_nh <- depmixS4::fit(model_nh)
depmixS4::summary(fmodel_nh)
```
```{r}
# MLE
mu1hat_nh <- paste0(round(fmodel_nh@response[[1]][[1]]@parameters$coefficients,3))
mu2hat_nh <- paste0(round(fmodel_nh@response[[2]][[1]]@parameters$coefficients,3))
mu3hat_nh <- paste0(round(fmodel_nh@response[[3]][[1]]@parameters$coefficients,3))
sd1hat_nh <- paste0(round(fmodel_nh@response[[1]][[1]]@parameters$sd,3))
sd2hat_nh <- paste0(round(fmodel_nh@response[[2]][[1]]@parameters$sd,3))
sd3hat_nh <- paste0(round(fmodel_nh@response[[3]][[1]]@parameters$sd,3))
# se(MLE)
MLEse_nh=depmixS4::standardError(fmodel_nh)
se_mu1hat_nh <- paste0('(', round(MLEse_nh$se[22],3), ')')
se_mu2hat_nh <- paste0('(', round(MLEse_nh$se[24],3), ')')
se_mu3hat_nh <- paste0('(', round(MLEse_nh$se[26],3), ')')
se_sd1hat_nh <- paste0('(', round(MLEse_nh$se[23],3), ')')
se_sd2hat_nh <- paste0('(', round(MLEse_nh$se[25],3), ')')
se_sd3hat_nh <- paste0('(', round(MLEse_nh$se[27],3), ')')
```
```{r}
# Summary table creation
MLEsum <- data.frame(state=c(rep("S=1",2), rep("S=2",2), rep("S=3",2)),
                     mu=c(mu1hat_nh, se_mu1hat_nh, mu2hat_nh, se_mu2hat_nh,
                          mu3hat_nh, se_mu3hat_nh),
                     sd=c(sd1hat_nh, se_sd1hat_nh, sd2hat_nh, se_sd2hat_nh,
                          sd3hat_nh, se_sd3hat_nh))
knitr::kable(MLEsum, "latex", booktabs=T, align="c",
             col.names = c("State", "$\\hat{\\mu}_{MLE}$", "$\\hat{\\sigma}_{MLE}$"),
             escape=F, caption="Maximum Likelihood estimates of the state-dependent
             mean and standard deviation\\label{tab:HMM_MLE_nh}") %>%
  column_spec(1:3, width="5em") %>%
  collapse_rows(columns=1, latex_hline="none") %>%
  footnote(general="Standard errors in parentheses",
           general_title="Note:",
           footnote_as_chunk=T, escape=F) %>%
  kable_styling(latex_options="hold_position")
```

Then, in order to find the optimal state variable path, we perform the global decoding procedure based on the \textit{Viterbi algorithm}.
Viterbi states and state-dependent means in the non-homogeneous HMM case are plotted respectively in Figure \ref{fig:model_fit_ost_nh} and Figure \ref{fig:model_fit_rsm_nh}.

```{r}
# Get the estimated state for each timestep 
estStates_nh <- posterior(fmodel_nh)
```

```{r, fig.width=6.5, fig.height=3, fig.cap="\\label{fig:model_fit_ost_nh}Optimal state trajectory (non-homogeneous HMM)"}

# Plot the optimal path, that is stored in the first column of estStates
F1_nh <- ggplot(data.frame(data_a4[1],data_a4[6], estStates_nh[1]))+
  geom_line(aes(x=Time,y=ITAbond_real)) +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="Real interest rate", x="Date") +
  scale_x_date(date_breaks="3 years", 
               date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'),
                              tryFormats=c("%Y_%m_%d"),
                              optional=FALSE),
               labels=date_format("%Y-%m")) +
  scale_y_continuous(breaks=seq(0,6,1)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("Real interest rate")

S1_nh <- ggplot(data.frame(data_a4[1],data_a4[6], estStates_nh[1])) +
  geom_line(aes(x=Time, y=state), 
            linetype="solid", 
            color="red") +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="State", x="Date") +
  scale_x_date(date_breaks="3 years", 
               date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'),
                              tryFormats=c("%Y_%m_%d"),
                              optional=FALSE),
               labels=date_format("%Y-%m")) +
  scale_y_continuous(breaks=seq(0,3,1)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("Viterbi states")

# Merge graphs in one plot
ggarrange(F1_nh, S1_nh,
          ncol=1, nrow=2)
```

```{r, fig.width=6, fig.height=2.5, fig.cap="\\label{fig:model_fit_rsm_nh}Regime switching mean (non-homogeneous HMM)"}

# Chart with state-dependent mean
estMeans_nh=matrix(0, length(data_a4[,1]),3)

for (i in 1:3) {
  for (j in 1:length(data_a4[,1])) {
    if (estStates_nh[j,1]==i){
      estMeans_nh[j,i]<-fmodel_nh@response[[i]][[1]]@parameters$coefficients
   }else{
      estMeans_nh[j,i]<-0
   }
  }
}

switching_mean_nh <- estMeans_nh[,1]+estMeans_nh[,2]+estMeans_nh[,3]

ggplot(data.frame(switching_mean_nh, data_a4[1],data_a4[6])) +
  geom_line(aes(x=Time, y=ITAbond_real)) +
  geom_point(aes(x=Time, y=switching_mean_nh), col="blue", size=.05) +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="Real interest rate", x="Date") +
  scale_x_date(date_breaks="3 years",
               date_minor_breaks="1 year",
               limits=as.Date(c('1997_01_01','2019_07_01'),
                              tryFormats=c("%Y_%m_%d"),
                              optional=FALSE),
               labels=date_format("%Y-%m")) +
  scale_y_continuous(breaks = seq(0,6,1)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("State dependent mean")
```

\end{enumerate}

\section{Final project: First part}

Our idea: \dots

\section{Activity tracking data}

In this exercise we use the \texttt{tracking\_data} dataset, which contains data of 45 bike rides. Specifically, each ride is described by the following variables:
\begin{itemize}
\item average speed (\texttt{speed})
\item heart rate (\texttt{bpm})
\item elevation (\texttt{elev})
\end{itemize}
which are measured at regular 30-second intervals, for a total duration of 2 hours.

```{r echo=FALSE}
# Import the dataset
tracks_df <- read.csv(url("https://raw.githubusercontent.com/LucaBadolato/TimeSeries-/master/tracking_data_start=30min_record=120min_freq=30sec.csv"), sep="\t", dec=".", header=T)
```

Given that elevation gains/losses are more informative than elevation itself, we create the variable \texttt{dfelev} by first differenting \texttt{elev}.
We report in Table \ref{tab:tracks_df} the first five observations of the dataset.

```{r echo=FALSE}
# Create the variable dfelev
dfelev <- tracks_df$elev - lag(tracks_df$elev)
dfelev[1] <- 0
tracks_df <- cbind(tracks_df, dfelev)
```

```{r}
# How the dataset looks like
knitr::kable(tracks_df[1:5, c(1:5, 8)], "latex", booktabs=T,
             caption="Dataset structure\\label{tab:tracks_df}") %>%
  kable_styling(latex_options = "hold_position")
```

\begin{enumerate}

\item %1
Let's consider activity \texttt{track\_id==38}.
The time series of interest are plotted in Figure \ref{fig:plots}.
  
```{r echo=FALSE}
# Create the data frame containing activity 38 only
which_track <- 38
track_38 <- tracks_df %>% 
  filter(track_id==which_track)
track_38$dfelev[1] <- 0 #taking the lags with the previous observation, we have to set the first 
                        #observation equal to 0, otherwise we would subtract the elevation of the                         #previous activity. 
```

```{r, fig.width=6, fig.height=3.5, fig.cap="\\label{fig:plots} Recorded bpm, speed and elevation gains/losses of activity 38"}

# Time series plot
B <- ggplot(track_38, aes(x=time, y=bpm)) +
  geom_line(color="steelblue") +
  theme_classic(base_size=9) +
  labs(y="Heart rate (bpm)", x="Time (sec)") +
  scale_x_continuous(breaks=seq(2000,9000,1000)) +
  scale_y_continuous(breaks=seq(100,170,10)) +
  theme(axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5)))

S <- ggplot(track_38, aes(x=time, y=speed)) +
  geom_line(color="steelblue") +
  theme_classic(base_size=9) +
  labs(y="Speed (km/h)", x="Time (sec)") +
  scale_x_continuous(breaks=seq(2000,9000,1000)) +
  scale_y_continuous(breaks=seq(10,60,10)) +
  theme(axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5)))

EG <- ggplot(track_38, aes(x=time, y=dfelev)) +
  geom_line(color="steelblue") +
  theme_classic(base_size=9) +
  labs(y="Elev. gains/losses", x="Time (sec)") +
  scale_x_continuous(breaks=seq(2000,9000,1000)) +
  scale_y_continuous(breaks=seq(-20,10,5)) +
  theme(axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5)))

ggarrange(B, S, EG,
          ncol=1, nrow=3)
```

We restrict our attention to the heart rate (\texttt{bpm}) data. It is possible to see that the time series does not look stationary and that several change points characterize the plot, e.g. at 4600sec and 5400sec. Therefore, it is not possible to analyse this series with the well-known ARMA models, which require stationarity (or non-stationary time series that can be easily trasformed into stationary ones). A suitable class of models for these cases is given by the Hidden Markov Models.

Let's indeed model the series using a \textit{homogeneous} HMM, with a latent process $(S_{t})_{t\geq0}$ representing the required athletic effort.

\textbf{Step 1: Model specification}

Let's assume:
\begin{itemize}
\item three hidden states, representing low effort, medium effort and high effort. Therefore, the state space of the latent process is $\mathcal{Y}=\{1,2,3\}$;
\item Gaussian emission distributions, with state-dependent mean $\mu_i$ and variance $\sigma_i$ with $i=1,2,3$.
\end{itemize}

\begin{align*}
\begin{cases}
Y_{t}=\mu_{1}+\varepsilon_{t}, \quad \varepsilon_{t}\overset{i.i.d.}{\sim}N(0,\sigma_{1}^2) \qquad \text{if} \; S_{t}=1 \\
Y_{t}=\mu_{2}+\varepsilon_{t}, \quad \varepsilon_{t}\overset{i.i.d.}{\sim}N(0,\sigma_{2}^2) \qquad \text{if} \; S_{t}=2 \\
Y_{t}=\mu_{3}+\varepsilon_{t}, \quad \varepsilon_{t}\overset{i.i.d.}{\sim}N(0,\sigma_{3}^2) \qquad \text{if} \; S_{t}=3
\end{cases}
\end{align*}

```{r}
# 1) Model specification
y <- as.numeric(track_38$bpm)
model_bpm <- depmixS4::depmix(y ~ 1, data=data.frame(y), nstates=3)
```

\textbf{Step 2: Estimation of the unknown parameters}

We estimate the unknown parameters by maximum likelihood, using an \textit{Expectation-Maximization} (EM) \textit{algorithm}. In Table \ref{tab:HMM_MLE_bpm} we report the estimated means and standard deviations of the three states with the associated standard errors. 

```{r include=FALSE}
# 2) Estimation of the unknown parameters
# MLE
fmodel_bpm <- depmixS4::fit(model_bpm)
depmixS4::summary(fmodel_bpm)
mu1hat_bpm <- paste0(round(fmodel_bpm@response[[1]][[1]]@parameters$coefficients,3))
mu2hat_bpm <- paste0(round(fmodel_bpm@response[[2]][[1]]@parameters$coefficients,3))
mu3hat_bpm <- paste0(round(fmodel_bpm@response[[3]][[1]]@parameters$coefficients,3))
sd1hat_bpm <- paste0(round(fmodel_bpm@response[[1]][[1]]@parameters$sd,3))
sd2hat_bpm <- paste0(round(fmodel_bpm@response[[2]][[1]]@parameters$sd,3))
sd3hat_bpm <- paste0(round(fmodel_bpm@response[[3]][[1]]@parameters$sd,3))
# se(MLE)
MLEse_bpm=depmixS4::standardError(fmodel_bpm)
se_mu1hat_bpm <- paste0('(', round(MLEse_bpm$se[13],3), ')')
se_mu2hat_bpm <- paste0('(', round(MLEse_bpm$se[15],3), ')')
se_mu3hat_bpm <- paste0('(', round(MLEse_bpm$se[17],3), ')')
se_sd1hat_bpm <- paste0('(', round(MLEse_bpm$se[14],3), ')')
se_sd2hat_bpm <- paste0('(', round(MLEse_bpm$se[16],3), ')')
se_sd3hat_bpm <- paste0('(', round(MLEse_bpm$se[18],3), ')')
```

```{r}
# Summary table creation
MLEsum_bpm <- data.frame(state=c(rep("S=1",2), rep("S=2",2), rep("S=3",2)), 
                         mu=c(mu1hat_bpm, se_mu1hat_bpm, mu2hat_bpm, se_mu2hat_bpm, 
                              mu3hat_bpm, se_mu3hat_bpm),
                         sd=c(sd1hat_bpm, se_sd1hat_bpm, sd2hat_bpm, se_sd2hat_bpm,
                              sd3hat_bpm, se_sd3hat_bpm))
knitr::kable(MLEsum_bpm, "latex", booktabs=T, align="c",
             col.names = c("State", "$\\hat{\\mu}_{MLE}$", "$\\hat{\\sigma}_{MLE}$"),
             escape=F, caption="Maximum Likelihood estimates of the state-dependent
             mean and standard deviation\\label{tab:HMM_MLE_bpm}") %>%
  column_spec(1:3, width="5em") %>%
  collapse_rows(columns=1, latex_hline="none") %>%
  footnote(general="Standard errors in parentheses",
           general_title="Note:",
           footnote_as_chunk=T, escape=F) %>%
  kable_styling(latex_options="hold_position")
```

\item %2

\textbf{Step 3: Decoding}

Finally, we find the "optimal" state sequence associated with the observed \texttt{bpm} time series. The optimization problem is solved using the \textit{Viterbi algorithm} and the results are shown in Figure \ref{fig:model_fit_ost_bpm}.

```{r}
# Get the estimated state for each timestep 
estStates_bpm <- posterior(fmodel_bpm)
```

```{r, fig.width=6, fig.height=3, fig.cap="\\label{fig:model_fit_ost_bpm}Optimal state trajectory"}

# Plot the optimal path, that is stored in the first column of estStates
F1_bpm <- ggplot(data.frame(track_38[2],track_38[3], estStates_bpm[1])) +
  geom_line(aes(x=time,y=bpm)) +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="Heart rate (bpm)", x="Time (sec)") +
  scale_x_continuous(breaks=seq(2000,9000,1000)) +
  scale_y_continuous(breaks=seq(100,170,10)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("Bpm")

S1_bpm <- ggplot(data.frame(track_38[2],track_38[3], estStates_bpm[1])) +
  geom_line(aes(x=time, y=state), 
            linetype="solid", 
            color="black") +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="State", x="Time (sec)") +
  scale_x_continuous(breaks=seq(2000,9000,1000)) +
  scale_y_continuous(breaks=seq(0,3,1)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("Viterbi states")

# Merge graphs in one plot
ggarrange(F1_bpm, S1_bpm,
          ncol=1, nrow=2)
```

The series with HMM estimated state-dependent means are shown in Figure \ref{fig:model_fit_rsm_bpm}.

```{r, fig.width=6, fig.height=2.5, fig.cap="\\label{fig:model_fit_rsm_bpm}Regime switching mean"}

# Chart with state-dependent mean
estMeans_bpm=matrix(0, length(track_38[,1]),3)

for (i in 1:3) {
  for (j in 1:length(track_38[,1])) {
    if (estStates_bpm[j,1]==i){
      estMeans_bpm[j,i]<-fmodel_bpm@response[[i]][[1]]@parameters$coefficients
   }else{
      estMeans_bpm[j,i]<-0
   }
  }
}

switching_mean_bpm <- estMeans_bpm[,1]+estMeans_bpm[,2]+estMeans_bpm[,3]

ggplot(data.frame(switching_mean_bpm, track_38[2],track_38[3])) +
  geom_line(aes(x=time, y=bpm)) +
  geom_point(aes(x=time, y=switching_mean_bpm), col="blue", size=.05) +
  theme_classic(base_size=9) +
  theme(plot.title=element_text(hjust=0.5)) +
  labs(y="Heart rate (bpm)", x="Time (sec)") +
  scale_x_continuous(breaks=seq(2000,9000,1000)) +
  scale_y_continuous(breaks=seq(100,170,10)) +
  theme(plot.title=element_text(size=10, face="bold", margin=margin(0,0,10,0)),
        axis.title.x=element_text(family="Times", margin=margin(t=5)),
        axis.title.y=element_text(family="Times", margin=margin(r=5))) +
  ggtitle("State dependent mean")
```

\end{enumerate}
